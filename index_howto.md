## Первичный ключ

### Лучше всегда иметь `PRIMARY KEY` в таблице

В большинстве случаев для таблиц InnoDB в MySQL лучше всего добавлять первичный ключ (индекс) по числовому полю.
Это упростит работу с таблицей и позволит обращаться к записям по ключам. Наличие первичного числового индекса, также ускоряет работу репликации MySQL, при изменении или удаление больших
объемов данных.
К тому же, если вы не создадите `PRIMARY KEY ` MySQL создаст его сам, но у вас не будет доступа к нему.

Использование  bigint(20) unsigned предпочтительно.

```sql
CREATE TABLE `b_bx24_url` (
	`ID` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
	`DATE_CREATE` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	`URL` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '',
	PRIMARY KEY (`ID`),
	UNIQUE KEY `UX_DBNAME` (`URL`)
) ENGINE=InnoDB AUTO_INCREMENT=20342 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci
```

`поведение репликации может меняться в зависимости от настроек`

Ускорение работы репликации происходит за счет того, что будут переданы ID записей которые надо удалить или изменить.
Что естественно ускорит выполнение запроса на ней, если же не будет первичного ключа, то на реплике будет
выполняться запрос для каждой записи при для ее удаления или изменения. В результате чего, запрос может сильно замедлиться.

Использование составных первичных ключей, так же может быть не актуально в данном случае. Так как запрос на удаление
может не содержать всех полей ключа.

### Добавление `PRIMARY KEY` в составные индексы

При использовании таблиц InnoDB, не надо добавлять `PRIMARY KEY` в конец составного индекса.

```sql
KEY `UX_DBNAME` (`URL`, `ID`)
```
Так как InnoDB в конец каждого индекса добавляет ссылку на первичный индекс и приведенный выше индекс превращается в

```sql
KEY `UX_DBNAME` (`URL`, `ID`, `ID`)
```

## Общие рекомендации по индексам

### Индекс по строковым полям
При создании индексов для полей типа `TEXT` или `VARCHAR` может потребоваться ограничение длины индекса для поля.
```sql
KEY `UX_DBNAME` (`URL` (32))
```
Такое ограничение будет полезным если у вас в поле может сохраняться значительно больше символов, чем основная масса значений.
Ограничив таким образом индекс, значительно повысим его эффективность за счет уменьшения размера.

Также стоит обратить внимание на фильтрацию по большим значениям. Например, у есть колонка `service_id` значение 
в которой может быть до 1000 символов. В этом случае для быстрой фильтрации по значению этого поля лучше сохранит хеш 
от него, и добавить индекс именно на это поле с хешем. Это уменьшит размер индекса и повысит эффективность его использования.

### Работа с составными индексами

Порядок колонок в составном индексе важен и влияет на его работу. Рассмотрим на примере индекса.

```sql
KEY `IX_SOME_KEY` (`A`, `B`, `C`)
```

Индекс будет использоваться полностью в запросах:
```sql
A > 9
A = 9 AND B > 6
A = 9 AND B = 15 AND C = 11
A = 9 AND B IN (2,3) AND C > 3
```

Индекс будет использоваться частично:
```sql
A > 9 AND B = 6 -- будет использоваться только диапазон по первой колонке индекса
A = 9 AND B > 15 AND C = 11 -- будет использоваться первая колонка и диапазон по второй
```

Индекс не будет использоваться:
```sql
B > 6 -- в запросе нету первой колонки индекса
B = 15 AND C > 11 -- в запросе нету первой колонки индекса
```

MySQL будет использовать индекс, до тех пор пока ему в фильтре не встретится колонка с диапазоном (>, <, BETWEEN).
Эта колонка будет последней используемой колонкой из индекса. MySQL сможет продолжить использовать колонки из индекса, 
если встретит диапазон IN (). 

Таким образом при проектировании составного индекса, необходимо учитывать поля фильтра 
и операции над ними. Ставя на первое место те, которые есть в наибольшем количестве возможных фильтров. При прочих 
равных на первое место стоит выбирать наиболее селективные колонки.

### Индексы и сортировка

Добавление индекса позволяет ускорить сортировку. Так для запроса 

```sql
SELECT * FROM b_iblock_element ORDER BY SORT DESC LIMIT 10;
```
Хорошо подойдет индекс приведенный ниже. Если же его не будет, то MySQL начнет выполнять запрос с внешней сортировкой 
(filesort). Что достаточно дорого и медленно.
```sql
KEY `IX_SORT` (`SORT`)
```

Для ускорения запроса с фильтрацией и сортировкой, может использоваться составной индекс.
```sql
SELECT * FROM b_iblock_element WHERE IBLOCK_ID = 3 ORDER BY SORT DESC LIMIT 10;
KEY `IX_IBLOCK_SORT` (`IBLOCK_ID`, `SORT`)
```

Примеры работы составного индекса с сортировкой

```sql
KEY IX_KEY (`A`, `B`)
```
Индекс **будет** использоваться для сортировки
```sql
ORDER BY A -- сортировка по первой колонке индекса
A = 9 ORDER BY B -- фильтрация по первой колонке и сортировка по второй
ORDER BY A DESC, B DESC -- сортировка по двум колонкам, в одном направление
A > 9 ORDER BY A DESC -- диапазон и сортировка по первой колонке
```

Индекс **не будет** использоваться для сортировки 
```sql
ORDER BY B -- сортировка по второй колонке индекса
A > 9 ORDER BY B DESC -- диапазон по первой, сортировка по второй
A IN (3,4) ORDER BY B -- in диапазон по первой колонке
ORDER BY A ASC, B DESC -- сортировка по двум колонкам, в разных направлениях
```
