##Первичный ключ

###Лучше всегда иметь `PRIMARY KEY` в таблице

В большинстве случаев для таблиц InnoDB в MySQL лучше всего добавлять первичный ключ (индекс) по числовому полю.
Это упростит работу с таблицей и позволит обращаться к записям по ключам. Наличие первичного числового индекса, также ускоряет работу репликации MySQL, при изменении или удаление больших
объемов данных.
К тому же, если вы не создадите `PRIMARY KEY ` MySQL создаст его сам, но у вас не будет доступа к нему.

Использование  bigint(20) unsigned предпочтительно.

```sql
CREATE TABLE `b_bx24_url` (
	`ID` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
	`DATE_CREATE` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	`URL` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '',
	PRIMARY KEY (`ID`),
	UNIQUE KEY `UX_DBNAME` (`URL`)
) ENGINE=InnoDB AUTO_INCREMENT=20342 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci
```

`поведение репликации может меняться в зависимости от настроек`

Ускорение работы репликации происходит за счет того, что будут переданы ID записей которые надо удалить или изменить.
Что естественно ускорит выполнение запроса на ней, если же не будет первичного ключа, то на реплике будет
выполняться запрос для каждой записи при для ее удаления или изменения. В результате чего, запрос может сильно замедлиться.

Использование составных первичных ключей, так же может быть не актуально в данном случае. Так как запрос на удаление
может не содержать всех полей ключа.

###Добавление `PRIMARY KEY` в составные индексы

При использовании таблиц InnoDB, не надо добавлять `PRIMARY KEY` в конец составного индекса.

```sql
KEY `UX_DBNAME` (`URL`, `ID`)
```
Так как InnoDB в конец каждого индекса добавляет ссылку на первичный индекс и приведенный выше индекс превращается в

```sql
KEY `UX_DBNAME` (`URL`, `ID`, `ID`)
```

##Общие рекомендации по созданию индексов

###Индекс по строковым полям
При создании индексов для полей типа `TEXT` или `VARCHAR` может потребоваться ограничение длины индекса для поля.
```sql
KEY `UX_DBNAME` (`URL` (32))
```
Такое ограничение будет полезным если у вас в поле может сохраняться значительно больше символов, чем основная масса значений.
Ограничив таким образом индекс, можно будет значительно повысить его эффективность за счет снижения его размера.

Также стоит обратить внимание на фильтрацию по большим значениям. Например, у вас есть колонка `service_id` значение 
в которой может быть до 1000 символов. В этом случае для быстрой фильтрации по значению этого поля лучше сохранит хеш 
от него, и добавить индекс именно на это поле с хешем.


