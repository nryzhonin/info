## Рекомендации по работе с индексами

Наиболее важные советы по работе с индексами БД.

### Первичный ключ `PRIMARY KEY` в таблицах

В большинстве случаев для таблиц InnoDB в MySQL лучше всего использовать первичный ключ (индекс) по числовому полю.
Это упростит работу с таблицей и позволит обращаться к записям по ключам. Наличие первичного ключа, также ускоряет работу 
репликации MySQL, при изменении или удаление больших объемов данных.

К тому же, MySQL по умолчанию создает скрытый `PRIMARY KEY `, но в этом случае у вас не будет доступа к нему.

Использование  bigint(20) unsigned предпочтительно.

```sql
CREATE TABLE `b_bx24_url` (
	`ID` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
	`DATE_CREATE` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	`URL` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '',
	PRIMARY KEY (`ID`),
	UNIQUE KEY `UX_DBNAME` (`URL`)
) ENGINE=InnoDB AUTO_INCREMENT=20342 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci
```

Ускорение работы репликации происходит за счет того, что будут переданы ID записей которые надо удалить или изменить.
Что естественно ускорит выполнение запроса на реплике. Если же не будет первичного ключа, то на реплике будет
выполняться запрос для каждой записи, для ее удаления или изменения. В результате чего, запрос сильно замедлиться.

Использование составных первичных ключей, может быть не эффективно. Так как в запросе могут быть не все поля ключа.

### Добавление `PRIMARY KEY` в составные индексы

При использовании таблиц InnoDB, не надо добавлять `PRIMARY KEY` в конец составного индекса. Остальные типы таблиц для 
MySQL на данный момент считаем не актуальными и поэтому их не учитываем.

```sql
KEY `UX_DBNAME` (`URL`, `ID`)
```
Так как InnoDB в конец каждого индекса добавляет ссылку на первичный индекс и приведенный выше индекс превращается в

```sql
KEY `UX_DBNAME` (`URL`, `ID`, `ID`)
```

### Ограничение размеров индекса и работа с большими полями
При создании индексов для полей типа `TEXT` или `VARCHAR` может потребоваться ограничение длины индекса для поля.
```sql
KEY `UX_DBNAME` (`URL` (32))
```
Для полей типа `TEXT` это ограничение необходимо, а для полей `VARCHAR` будет полезным если у вас в поле сохраняться
значительно больше символов, чем основная масса значений. Ограничив таким образом индекс, можно повысить его эффективность 
за счет уменьшения его размера.

Также стоит обратить внимание на фильтрацию по большим значениям. Например, у есть колонка `service_id` значение 
в которой может быть до 1000 символов. В этом случае для быстрой фильтрации по значению этого поля лучше сохранит 
хеш от него в отдельном поле, и добавить индекс именно на это поле. По которому в итоге и осуществлять поиск.
В результате эффективность запроса повыситься за счет уменьшения размера индекса.

### Работа с составными индексами

Порядок колонок в составном индексе важен и влияет на эффективность индекса. Рассмотрим на примере индекса.

```sql
KEY `IX_SOME_KEY` (`A`, `B`, `C`)
```

Индекс будет использоваться полностью в запросах:
```sql
A > 9
A = 9 AND B > 6
A = 9 AND B = 15 AND C = 11
A = 9 AND B IN (2,3) AND C > 3
```

Индекс будет использоваться частично:
```sql
A > 9 AND B = 6 -- будет использоваться только диапазон по первой колонке индекса
A = 9 AND B > 15 AND C = 11 -- будет использоваться первая колонка и диапазон по второй
```

Индекс не будет использоваться:
```sql
B > 6 -- в запросе нету первой колонки индекса
B = 15 AND C > 11 -- в запросе нету первой колонки индекса
```

MySQL будет использовать индекс, до тех пор пока ему в фильтре не встретится колонка с диапазоном (>, <, BETWEEN, LIKE).
Эта колонка будет последней используемой колонкой из индекса. MySQL сможет продолжить использовать колонки из индекса, 
если встретит диапазон IN (). 

Таким образом при проектировании составного индекса, необходимо учитывать поля фильтра и операции над ними. При прочих
равных, выдвигая вперед те поля, которые есть в наибольшем количестве фильтров.

### Индексы и сортировка

Использование индексов также ускоряет и сортировку. Например, для запроса
```sql
SELECT * FROM b_iblock_element ORDER BY SORT DESC LIMIT 10;
```
подойдет индекс приведенный ниже. 
```sql
KEY `IX_SORT` (`SORT`)
```
Если же этого индекса не будет, то MySQL начнет выполнять запрос с внешней сортировкой (filesort), что дорого и медленно.

Для ускорения запроса с фильтрацией и сортировкой, необходимо использоваться составной индекс.
```sql
SELECT * FROM b_iblock_element WHERE IBLOCK_ID = 3 ORDER BY SORT DESC LIMIT 10;
KEY `IX_IBLOCK_SORT` (`IBLOCK_ID`, `SORT`)
```

Принцип использования индекса для сортировки с фильтром и без.

```sql
KEY IX_KEY (`A`, `B`)
```
Индекс **будет** использоваться для сортировки
```sql
ORDER BY A -- сортировка по первой колонке индекса
A = 9 ORDER BY B -- фильтрация по первой колонке и сортировка по второй
ORDER BY A DESC, B DESC -- сортировка по двум колонкам, в одном направление
A > 9 ORDER BY A DESC -- диапазон и сортировка по первой колонке
```

Индекс **не будет** использоваться для сортировки 
```sql
ORDER BY B -- сортировка по второй колонке индекса
A > 9 ORDER BY B DESC -- диапазон по первой, сортировка по второй
A IN (3,4) ORDER BY B -- in диапазон по первой колонке
ORDER BY A ASC, B DESC -- сортировка по двум колонкам, в разных направлениях
```

### Join и индексы

MySQL использует в основном алгоритм Nested Loops для джоина таблиц. 

```sql
SELECT * FROM POSTS, COMMENTS WHERE AUTHOR = 15 AND COMMENTS.POST_ID = POSTS.ID
```
Так, при выполнении данного запроса БД вначале пробежит по таблице POSTS и найдет записи с автором 15. 
И для каждой найденной записи сделает полную переборку таблицы COMMENTS, что бы присоединить комментарии. Таким образом 
самым дорогим тут будет поиск по таблице комментариев. И с ростом постов и комментариев запрос будет деградировать.

Поэтому для всех запросов с Join необходимо создавать индексы в присоединяемых таблицах по тем полям, по которым идет 
объединение.

Для запроса выше, это будет 
```sql

ALTER TABLE COMMENTS ADD INDEX IX_POST_ID (POST_ID); -- обязательный индекс для Join 
ALTER TABLE POSTS ADD INDEX ID_AUTHOR (AUTHOR); -- индекс для ускорения фильтрации авторов в первой таблице.
```
При этом индекс по POSTS.ID в данном случае, для ускорения запросов, не нужен. Но при Join может произойти перекос 
данных и MySQL начнет фильтровать вначале по таблице из Join, а потом уже по основной. В этом случае необходим индекс и 
в обратную сторону. ( Для простоты пример приведен на POST.ID, считаем что это не PK )
